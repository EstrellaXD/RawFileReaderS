//! Integration tests comparing Rust parser output against official Thermo library ground truth.
//!
//! These tests require:
//! 1. A real RAW file at `test-data/raw-files/exp005_250130_andrii_ex5_blank_002.raw`
//! 2. Ground truth JSON at `tools/ground-truth/output/` (generated by export_ground_truth.py)
//!
//! Run with: `cargo test -p thermo-raw --test ground_truth_tests`
//! Tests are #[ignore] by default since they require test data files.

use std::collections::HashMap;
use std::path::Path;

/// Path to the test RAW file (relative to workspace root).
/// Uses the NEW file (Orbitrap Astral, 226918 scans) which is accessible via Thermo .NET.
const RAW_FILE_PATH: &str = "../data/exp246_260209_SK_A1B1_SAH_5nM_07.raw";
/// Path to ground truth output directory.
const GROUND_TRUTH_DIR: &str = "tools/ground-truth/output";

fn workspace_root() -> std::path::PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap()
        .parent()
        .unwrap()
        .to_path_buf()
}

fn raw_file_path() -> std::path::PathBuf {
    workspace_root().join(RAW_FILE_PATH)
}

fn ground_truth_path() -> std::path::PathBuf {
    workspace_root().join(GROUND_TRUTH_DIR)
}

fn load_json<T: serde::de::DeserializeOwned>(path: &Path) -> T {
    let data = std::fs::read_to_string(path)
        .unwrap_or_else(|e| panic!("Failed to read {}: {}", path.display(), e));
    serde_json::from_str(&data)
        .unwrap_or_else(|e| panic!("Failed to parse {}: {}", path.display(), e))
}

/// Test that basic file metadata matches the ground truth.
#[test]
#[ignore]
fn test_metadata_matches() {
    let raw = thermo_raw::RawFile::open(raw_file_path()).unwrap();
    let truth: HashMap<String, serde_json::Value> =
        load_json(&ground_truth_path().join("metadata.json"));

    let expected_n_scans = truth["n_scans"].as_u64().unwrap() as u32;
    let expected_first = truth["first_scan"].as_u64().unwrap() as u32;
    let expected_last = truth["last_scan"].as_u64().unwrap() as u32;

    assert_eq!(raw.n_scans(), expected_n_scans, "n_scans mismatch");
    assert_eq!(raw.first_scan(), expected_first, "first_scan mismatch");
    assert_eq!(raw.last_scan(), expected_last, "last_scan mismatch");

    let expected_start_time = truth["start_time"].as_f64().unwrap();
    let expected_end_time = truth["end_time"].as_f64().unwrap();
    assert!(
        (raw.start_time() - expected_start_time).abs() < 0.01,
        "start_time: got {}, expected {}",
        raw.start_time(),
        expected_start_time
    );
    assert!(
        (raw.end_time() - expected_end_time).abs() < 0.01,
        "end_time: got {}, expected {}",
        raw.end_time(),
        expected_end_time
    );

    let expected_low = truth["low_mass"].as_f64().unwrap();
    let expected_high = truth["high_mass"].as_f64().unwrap();
    assert!(
        (raw.low_mass() - expected_low).abs() < 1.0,
        "low_mass: got {}, expected {}",
        raw.low_mass(),
        expected_low
    );
    assert!(
        (raw.high_mass() - expected_high).abs() < 1.0,
        "high_mass: got {}, expected {}",
        raw.high_mass(),
        expected_high
    );
}

/// Test that per-scan index data (RT, TIC, base peak) matches ground truth.
#[test]
#[ignore]
fn test_scan_index_matches() {
    let raw = thermo_raw::RawFile::open(raw_file_path()).unwrap();
    let truth: Vec<HashMap<String, serde_json::Value>> =
        load_json(&ground_truth_path().join("scan_index.json"));

    let index = raw.scan_index();
    assert_eq!(
        index.len(),
        truth.len(),
        "scan count mismatch: got {}, expected {}",
        index.len(),
        truth.len()
    );

    let mut rt_errors = 0;
    let mut tic_errors = 0;
    for (i, (entry, expected)) in index.iter().zip(truth.iter()).enumerate() {
        let expected_rt = expected["rt"].as_f64().unwrap();
        if (entry.rt - expected_rt).abs() > 0.001 {
            if rt_errors < 5 {
                eprintln!(
                    "  RT mismatch at scan {}: got {}, expected {}",
                    i + 1,
                    entry.rt,
                    expected_rt
                );
            }
            rt_errors += 1;
        }

        let expected_tic = expected["tic"].as_f64().unwrap();
        let tic_rel_err = if expected_tic != 0.0 {
            ((entry.tic - expected_tic) / expected_tic).abs()
        } else {
            0.0
        };
        if tic_rel_err > 0.001 {
            if tic_errors < 5 {
                eprintln!(
                    "  TIC mismatch at scan {}: got {}, expected {} (rel err: {:.6})",
                    i + 1,
                    entry.tic,
                    expected_tic,
                    tic_rel_err
                );
            }
            tic_errors += 1;
        }
    }

    assert_eq!(rt_errors, 0, "{} scans had RT mismatches", rt_errors);
    assert_eq!(tic_errors, 0, "{} scans had TIC mismatches", tic_errors);
}

/// Test that centroid m/z values match ground truth within 1 ppm tolerance.
#[test]
#[ignore]
fn test_centroid_mz_tolerance() {
    let raw = thermo_raw::RawFile::open(raw_file_path()).unwrap();
    let centroids_dir = ground_truth_path().join("centroids");

    // TODO(human): Implement the m/z comparison logic.
    // See the guidance in the Learn by Doing section below.
    // For now, this just loads and iterates the ground truth files.
    let mut total_peaks = 0;
    let mut max_ppm_error = 0.0f64;
    let mut scans_tested = 0;

    for entry in std::fs::read_dir(&centroids_dir).unwrap() {
        let path = entry.unwrap().path();
        if !path.extension().map_or(false, |e| e == "json") {
            continue;
        }

        let truth: HashMap<String, serde_json::Value> = load_json(&path);
        let scan_num = truth["scan_number"].as_u64().unwrap() as u32;
        let expected_mz: Vec<f64> = truth["mz"]
            .as_array()
            .unwrap()
            .iter()
            .map(|v| v.as_f64().unwrap())
            .collect();
        let _expected_int: Vec<f64> = truth["intensity"]
            .as_array()
            .unwrap()
            .iter()
            .map(|v| v.as_f64().unwrap())
            .collect();

        let scan = raw.scan(scan_num).unwrap();

        // Compare peak counts -- allow small differences due to filtering
        let n_expected = expected_mz.len();
        let n_got = scan.centroid_mz.len();
        if n_expected == 0 && n_got == 0 {
            scans_tested += 1;
            continue;
        }

        assert!(
            n_got > 0,
            "scan {}: got 0 peaks but expected {}",
            scan_num,
            n_expected
        );

        // Compare m/z arrays element-by-element if counts match
        if n_got == n_expected {
            for (i, (&got_mz, &exp_mz)) in
                scan.centroid_mz.iter().zip(expected_mz.iter()).enumerate()
            {
                let ppm_err = if exp_mz != 0.0 {
                    ((got_mz - exp_mz) / exp_mz).abs() * 1e6
                } else {
                    0.0
                };
                if ppm_err > max_ppm_error {
                    max_ppm_error = ppm_err;
                }
                assert!(
                    ppm_err < 10.0,
                    "scan {} peak {}: m/z {} vs expected {}, ppm error = {:.2}",
                    scan_num,
                    i,
                    got_mz,
                    exp_mz,
                    ppm_err
                );
            }
            total_peaks += n_expected;
        } else {
            eprintln!(
                "  scan {}: peak count mismatch: got {}, expected {}",
                scan_num, n_got, n_expected
            );
        }

        scans_tested += 1;
    }

    eprintln!(
        "  Tested {} scans, {} peaks, max ppm error: {:.4}",
        scans_tested, total_peaks, max_ppm_error
    );
    assert!(scans_tested > 0, "no ground truth centroid files found");
}

/// Test that activation types (HCD, CID, etc.) are correctly identified.
#[test]
#[ignore]
fn test_activation_types() {
    let raw = thermo_raw::RawFile::open(raw_file_path()).unwrap();
    let truth: Vec<HashMap<String, serde_json::Value>> =
        load_json(&ground_truth_path().join("scan_events.json"));

    let mut mismatches = 0;
    for expected in &truth {
        let scan_num = expected["scan_number"].as_u64().unwrap() as u32;
        let expected_activation = expected["activation_type"].as_str().unwrap();
        let expected_ms_level = expected["ms_level"].as_u64().unwrap() as u8;

        // Only check activation for MS2+ scans
        if expected_ms_level < 2 {
            continue;
        }

        let scan = raw.scan(scan_num).unwrap();
        if let Some(precursor) = &scan.precursor {
            if let Some(activation) = &precursor.activation_type {
                // Normalize activation type strings for comparison
                let got = activation.to_uppercase();
                let exp = expected_activation.to_uppercase();
                if got != exp && exp != "NONE" {
                    if mismatches < 10 {
                        eprintln!(
                            "  scan {}: activation '{}' vs expected '{}'",
                            scan_num, got, exp
                        );
                    }
                    mismatches += 1;
                }
            }
        }
    }

    assert!(
        mismatches == 0,
        "{} scans had activation type mismatches",
        mismatches
    );
}

/// Test that MS levels (MS1 vs MS2) are correctly classified.
#[test]
#[ignore]
fn test_ms_levels() {
    let raw = thermo_raw::RawFile::open(raw_file_path()).unwrap();
    let truth: Vec<HashMap<String, serde_json::Value>> =
        load_json(&ground_truth_path().join("scan_events.json"));

    let mut mismatches = 0;
    for expected in &truth {
        let scan_num = expected["scan_number"].as_u64().unwrap() as u32;
        let expected_level = expected["ms_level"].as_u64().unwrap() as u8;

        let scan = raw.scan(scan_num).unwrap();
        let got_level = match scan.ms_level {
            thermo_raw::MsLevel::Ms1 => 1,
            thermo_raw::MsLevel::Ms2 => 2,
            thermo_raw::MsLevel::Ms3 => 3,
            thermo_raw::MsLevel::Other(n) => n,
        };

        if got_level != expected_level {
            if mismatches < 10 {
                eprintln!(
                    "  scan {}: MS level {} vs expected {}",
                    scan_num, got_level, expected_level
                );
            }
            mismatches += 1;
        }
    }

    assert!(
        mismatches == 0,
        "{} scans had MS level mismatches",
        mismatches
    );
}
